C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:52:57 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\Output\main.obj
COMPILER INVOKED BY: E:\mcu_keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND PRINT(..\Listing\main.lst) TABS(2) OBJ
                    -ECT(..\Output\main.obj)

line level    source

   1          /**********************************************************************************
   2           * 工程名  :短信控制LED
   3           * 描述    :通过短信控制开发板的LED
   4           * 实验平台:C51
   5           * 库版本  :
   6          
   7           * 硬件连接说明
   8             使用单片串口与GPRS模块通信 
   9             C51        GPRS模块
  10             P30 (RXD)->RXD
  11             P31 (TXD)->TXD
  12             GND      ->GND
  13          
  14           * 软件功能说明
  15             板子上电后运行指示灯RUNING_LED会以一秒的频率闪烁
  16             手机发送“onled”点亮LED；
  17             手机发送“offled”熄灭LED；
  18          **********************************************************************************/
  19          #include "config.h"
  20          #include "string.h"
  21          #include "delay.h"
  22          #include "uart.h"
  23          
  24          #define Automatic_Startup 1     //定义自启动 V1.2版本起有自启动功能
  25          
  26          #define Buf1_Max 200            //串口1缓存长度
  27          /*************  本地常量声明  **************/
  28          sbit RUNING_LED = P1^2;         //运行指示灯
  29          sbit LED        = P1^3;         //控制指示灯
  30          
  31          
  32          /*************  本地变量声明  **************/
  33          xdata u8 Uart1_Buf[Buf1_Max];
  34          
  35          u8 Times=0,First_Int = 0,shijian=0;
  36          
  37          bdata u8 Flag;//定时器标志位
  38          sbit Timer0_start =Flag^0;  //定时器0延时启动计数器
  39          
  40          
  41          
  42          /*************  本地函数声明  **************/
  43          void GPIO_config(void);   //引脚初始化
  44          void Timer0Init(void);    //定时器0初始化
  45          void CLR_Buf1(void);      //清串口接收缓存
  46          u8 Find(u8 *a);           //查找字符串
  47          void Second_AT_Command(u8 *b,u8 *a,u8 wait_time);//发送指令
  48          void Wait_CREG(void);     //查询等待模块注册成功
  49          void Set_Text_Mode(void); //设置短信为TEXT模式
  50          void Check_New_Message(void);  //查询新短信
  51          
  52          
  53          /*************  外部函数和变量声明*****************/
  54          
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:52:57 PAGE 2   

  55          
  56          
  57          
  58          /*******************************************************************************
  59          * 函数名 : main 
  60          * 描述   : 主函数
  61          * 输入   : 
  62          * 输出   : 
  63          * 返回   : 
  64          * 注意   : 串口波特率是9600，GPRS模块默认波特率是115200，需要自己通过串口助手修改
  65                     为9600方可使用。 
  66                     程序会删除手机卡上的短信，请注意
  67          *******************************************************************************/
  68          void main(void)
  69          {
  70   1        Timer0Init();  //初始化定时器0
  71   1        GPIO_config();
  72   1        EA=1; //开总中断
  73   1        Uart1Init();    //初始化串口9600
  74   1        Wait_CREG();    //查询等待模块注册成功
  75   1        Set_Text_Mode();//设置短信为TEXT模式
  76   1        //Second_AT_Command("AT+CMGD=1,4","OK",3);//删除卡上所有短信
  77   1        while(1)
  78   1        {
  79   2          Check_New_Message();
  80   2        }
  81   1        
  82   1      }
  83          
  84          /*******************************************************************************
  85          * 函数名 : Uart1 
  86          * 描述   : 串口1中断服务入口函数
  87          * 输入   : 
  88          * 输出   : 
  89          * 返回   : 
  90          * 注意   : 
  91          *******************************************************************************/
  92          void Uart1() interrupt 4
  93          {
  94   1          if (RI)
  95   1          {
  96   2            RI = 0;                           //清除RI位
  97   2            Uart1_Buf[First_Int] = SBUF;      //将接收到的字符串存到缓存中
  98   2            First_Int++;                      //缓存指针向后移动
  99   2            if(First_Int > Buf1_Max)          //如果缓存满,将缓存指针指向缓存的首地址
 100   2            {
 101   3              First_Int = 0;
 102   3            }
 103   2          }
 104   1          if (TI)
 105   1          {
 106   2              TI = 0;                          //清除TI位
 107   2          }
 108   1      }
 109          
 110          /*******************************************************************************
 111          * 函数名 : Timer0_ISR
 112          * 描述   : 定时器0中断服务入口函数,20ms中断一次
 113          * 输入   : 
 114          * 输出   : 
 115          * 返回   : 
 116          * 注意   : 
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:52:57 PAGE 3   

 117          *******************************************************************************/
 118          void Timer0_ISR() interrupt 1
 119          {
 120   1        static u8 Time_count=0; 
 121   1        TR0=0;//关定时器
 122   1        TL0 = 0x00;   //重设定时器初值
 123   1        TH0 = 0xB8;   //重设定时器初值
 124   1        Time_count++;
 125   1        if(Time_count>=50)
 126   1        {
 127   2          Time_count = 0;
 128   2          RUNING_LED =~RUNING_LED;
 129   2        }
 130   1        if(count_20ms) //20ms延时计数器
 131   1          count_20ms--;
 132   1        if(Timer0_start)
 133   1          Times++;
 134   1        if(Times > (50*shijian))
 135   1        {
 136   2          Timer0_start = 0;
 137   2          Times = 0;
 138   2        }
 139   1        TR0=1;//开定时器
 140   1      }
 141          /*******************************************************************************
 142          * 函数名 : GPIO_config
 143          * 描述   : IO口配置函数
 144          * 输入   : 
 145          * 输出   : 
 146          * 返回   : 
 147          * 注意   : 
 148          *******************************************************************************/
 149          void  GPIO_config(void)
 150          {
 151   1          LED=1;
 152   1          RUNING_LED=1;
 153   1      }
 154          /*******************************************************************************
 155          * 函数名 : Timer0Init
 156          * 描述   : 定时器0初始化，20ms定时
 157          * 输入   : 
 158          * 输出   : 
 159          * 返回   : 
 160          * 注意   : 
 161          *******************************************************************************/
 162          void Timer0Init(void)   //20毫秒@11.0592MHz
 163          {
 164   1        AUXR &= 0x7F;   //定时器时钟12T模式
 165   1        TMOD &= 0xF0;   //
 166   1        TMOD |= 0x01;   //设置定时器模式，16位定时器
 167   1        TL0 = 0x00;     //设置定时器初值
 168   1        TH0 = 0xB8;     //设置定时器初值
 169   1        TF0 = 0;        //清TF0标志
 170   1        TR0 = 1;        //定时器0开始计时
 171   1        ET0 = 1;        //使能定时器0中断
 172   1      }
 173          /*******************************************************************************
 174          * 函数名 : CLR_Buf1
 175          * 描述   : 清除串口2缓存数据
 176          * 输入   : 
 177          * 输出   : 
 178          * 返回   : 
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:52:57 PAGE 4   

 179          * 注意   : 
 180          *******************************************************************************/
 181          void CLR_Buf1(void)
 182          {
 183   1        u16 k;
 184   1        for(k=0;k<Buf1_Max;k++)      //将缓存内容清零
 185   1        {
 186   2          Uart1_Buf[k] = 0x00;
 187   2        }
 188   1          First_Int = 0;              //接收字符串的起始存储位置
 189   1      }
 190          
 191          /*******************************************************************************
 192          * 函数名 : Find
 193          * 描述   : 判断缓存中是否含有指定的字符串
 194          * 输入   : 
 195          * 输出   : 
 196          * 返回   : unsigned char:1 找到指定字符，0 未找到指定字符 
 197          * 注意   : 
 198          *******************************************************************************/
 199          
 200          u8 Find(u8 *a)
 201          { 
 202   1        if(strstr(Uart1_Buf,a)!=NULL)
 203   1            return 1;
 204   1        else
 205   1            return 0;
 206   1      }
 207          
 208          /*******************************************************************************
 209          * 函数名 : Second_AT_Command
 210          * 描述   : 发送AT指令函数
 211          * 输入   : 发送数据的指针、希望收到的应答、发送等待时间(单位：S)
 212          * 输出   : 
 213          * 返回   : 
 214          * 注意   : 
 215          *******************************************************************************/
 216          
 217          void Second_AT_Command(u8 *b,u8 *a,u8 wait_time)         
 218          {
 219   1        u8 i;
 220   1        u8 *c;
 221   1        c = b;                    //保存字符串地址到c
 222   1        CLR_Buf1(); 
 223   1        i = 0;
 224   1        while(i == 0)                    
 225   1        {
 226   2          if(!Find(a))            //查找需要应答的字符
 227   2          {
 228   3            if(Timer0_start == 0)
 229   3            {
 230   4              b = c;              //将字符串地址给b
 231   4              for (b; *b!='\0';b++)
 232   4              {
 233   5                UART1_SendData(*b);
 234   5              }
 235   4              UART1_SendLR(); 
 236   4              Times = 0;
 237   4              shijian = wait_time;
 238   4              Timer0_start = 1;
 239   4             }
 240   3          }
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:52:57 PAGE 5   

 241   2          else
 242   2          {
 243   3            i = 1;
 244   3            Timer0_start = 0;
 245   3          }
 246   2        }
 247   1        CLR_Buf1(); 
 248   1      }
 249          
 250          /*******************************************************************************
 251          * 函数名 : Set_Text_Mode
 252          * 描述   : 设置短信为TEXT文本模式
 253          * 输入   : 
 254          * 输出   : 
 255          * 返回   : 
 256          * 注意   : 
 257          *******************************************************************************/
 258          void Set_Text_Mode(void)
 259          {
 260   1        Second_AT_Command("ATE0","OK",3);                     //取消回显  
 261   1        Second_AT_Command("AT+CNMI=3,2,0,0,0","OK",3);              //新短信直接输出
 262   1        Second_AT_Command("AT+CMGF=1","OK",3);                //TEXT模式  
 263   1        Second_AT_Command("AT+CPMS=\"SM\",\"SM\",\"SM\"","OK",3);   //所有操作都在SIM卡中进行 
 264   1      }
 265          
 266          /*******************************************************************************
 267          * 函数名 : Check_Message_rec
 268          * 描述   : 检查是否有新信息，并执行信息内容指令
 269          * 输入   : 
 270          * 输出   : 
 271          * 返回   : 
 272          * 注意   : 
 273          *******************************************************************************/
 274          
 275          void Check_New_Message(void)
 276          {
 277   1        u8 temp=0;
 278   1        if(strstr(Uart1_Buf,"+CMT")!=NULL)      //若缓存字符串中含有"+CMT"就表示有新的短信
 279   1        {
 280   2          delay_ms(3);//等待数据全部接收完成
 281   2          if(strstr(Uart1_Buf,"onled")!=NULL)
 282   2          {
 283   3            LED = 0;
 284   3          }
 285   2          if(strstr(Uart1_Buf,"offled")!=NULL)
 286   2          {
 287   3            LED = 1;
 288   3          }
 289   2          CLR_Buf1();
 290   2          //Second_AT_Command("AT+CMGD=1,4","OK",3);//删除短信
 291   2        }
 292   1      }
 293          
 294          /*******************************************************************************
 295          * 函数名 : Wait_CREG
 296          * 描述   : 等待模块注册成功
 297          * 输入   : 
 298          * 输出   : 
 299          * 返回   : 
 300          * 注意   : 
 301          *******************************************************************************/
 302          void Wait_CREG(void)
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:52:57 PAGE 6   

 303          {
 304   1        u8 i;
 305   1        u8 k;
 306   1        i = 0;
 307   1        CLR_Buf1();
 308   1        while(i == 0)             
 309   1        {
 310   2          CLR_Buf1();        
 311   2          UART1_SendString("AT+CREG?");//查询模块网络注册状态
 312   2          UART1_SendLR();
 313   2          delay_ms(250);              
 314   2          for(k=0;k<Buf1_Max;k++)           
 315   2          {
 316   3          if(Uart1_Buf[k] == ':')
 317   3          {
 318   4            if((Uart1_Buf[k+4] == '1')||(Uart1_Buf[k+4] == '5')) //表明网络注册成功
 319   4            {
 320   5              i = 1;
 321   5              break;
 322   5            }
 323   4          }
 324   3         }
 325   2        }
 326   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    601    ----
   CONSTANT SIZE    =     86    ----
   XDATA SIZE       =    200    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5      17
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
