C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:55:43 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\Output\main.obj
COMPILER INVOKED BY: E:\mcu_keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND PRINT(..\Listing\main.lst) TABS(2) OBJ
                    -ECT(..\Output\main.obj)

line level    source

   1          /**********************************************************************************
   2           * 工程名  :GPRS
   3           * 描述    :测试GPRS连接，并且服务器可以通过GPRS控制LED
   4           * 实验平台:C51
   5           * 库版本  :
   6          
   7           * 硬件连接说明
   8             使用单片串口与GPRS模块通信 
   9             C51        GPRS模块
  10             P30 (RXD)->RXD
  11             P31 (TXD)->TXD
  12             GND      ->GND
  13          
  14          
  15           * 软件功能说明
  16             板子上电后运行指示灯RUNING_LED会以一秒的频率闪烁
  17             服务器发送“onled”点亮LED；
  18             服务器发送“offled”熄灭LED；
  19             单片机每隔10秒会向服务器发送心跳帧“OK”
  20          **********************************************************************************/
  21          #include "config.h"
  22          #include "string.h"
  23          #include "delay.h"
  24          #include "uart.h"
  25          
  26          #define Automatic_Startup 1     //定义自启动 V1.2版本起有自启动功能
  27          
  28          #define Buf1_Max 200            //串口2缓存长度
  29          /*************  本地常量声明  **************/
  30          
  31          const u8 *string = "AT+CIPSTART=\"UDP\",\"116.31.51.113\",9015";  //IP登录服务器
  32          sbit RUNING_LED = P1^1;         //运行指示灯
  33          sbit LED        = P1^2;         //控制指示灯
  34          
  35          
  36          /*************  本地变量声明  **************/
  37          xdata u8 Uart1_Buf[Buf1_Max];
  38          
  39          u8 Times=0,First_Int = 0,shijian=0;
  40          u16 Heartbeat=0;
  41          //u8 Time_count=0;
  42          bdata u8 Flag;//定时器标志位
  43          sbit Timer0_start =Flag^0;  //定时器0延时启动计数器
  44          sbit Heart_beat   =Flag^1;  //发送心跳帧标志位
  45          
  46          /*************  本地函数声明  **************/
  47          void GPIO_config(void);
  48          void Timer0Init(void);
  49          void CLR_Buf2(void);
  50          u8 Find(u8 *a);
  51          void Second_AT_Command(u8 *b,u8 *a,u8 wait_time);
  52          void Set_ATE0(void);
  53          void Connect_Server(void);
  54          void Rec_Server_Data(void);
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:55:43 PAGE 2   

  55          void Wait_CREG(void);
  56          void Send_OK(void);
  57          
  58          /*************  外部函数和变量声明*****************/
  59          
  60          
  61          
  62          
  63          /*******************************************************************************
  64          * 函数名 : main 
  65          * 描述   : 主函数
  66          * 输入   : 
  67          * 输出   : 
  68          * 返回   : 
  69          * 注意   : 串口波特率是9600，GPRS模块默认波特率是115200，需要自己通过串口助手修改
  70                     为9600方可使用。
  71          *******************************************************************************/
  72          void main(void)
  73          {
  74   1        Timer0Init();  //初始化定时器0
  75   1        GPIO_config();
  76   1        EA=1; //开总中断
  77   1        Uart1Init();    //初始化串口9600
  78   1        Wait_CREG();    //查询等待模块注册成功
  79   1        Set_ATE0();     //取消回显
  80   1        Connect_Server();//配置GPRS服务
  81   1        while(1)
  82   1        {
  83   2          Rec_Server_Data(); //接收服务器下发的数据，并处理
  84   2          
  85   2          if(Heart_beat)     //发送心跳帧
  86   2          {
  87   3            Send_OK();
  88   3            Heart_beat=0;
  89   3          }
  90   2        }
  91   1      }
  92          
  93          /*******************************************************************************
  94          * 函数名 : Uart1 
  95          * 描述   : 串口1中断服务入口函数
  96          * 输入   : 
  97          * 输出   : 
  98          * 返回   : 
  99          * 注意   : 
 100          *******************************************************************************/
 101          void Uart1() interrupt 4
 102          {
 103   1          if (RI)
 104   1          {
 105   2            RI = 0;                           //清除RI位
 106   2            Uart1_Buf[First_Int] = SBUF;      //将接收到的字符串存到缓存中
 107   2            First_Int++;                      //缓存指针向后移动
 108   2            if(First_Int > Buf1_Max)          //如果缓存满,将缓存指针指向缓存的首地址
 109   2            {
 110   3              First_Int = 0;
 111   3            }
 112   2          }
 113   1          if (TI)
 114   1          {
 115   2              TI = 0;                          //清除TI位
 116   2          }
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:55:43 PAGE 3   

 117   1      }
 118          
 119          /*******************************************************************************
 120          * 函数名 : Timer0_ISR
 121          * 描述   : 定时器0中断服务入口函数,20ms中断一次
 122          * 输入   : 
 123          * 输出   : 
 124          * 返回   : 
 125          * 注意   : 
 126          *******************************************************************************/
 127          void Timer0_ISR() interrupt 1
 128          {
 129   1        static u8 Time_count=0; 
 130   1        TR0=0;//关定时器
 131   1        TL0 = 0x00;   //重设定时器初值
 132   1        TH0 = 0xB8;   //重设定时器初值
 133   1        Time_count++;
 134   1        if(Time_count>=50)//1秒运行指示灯闪烁
 135   1        {
 136   2          Time_count = 0;
 137   2          RUNING_LED =~RUNING_LED;
 138   2        }
 139   1        if(count_20ms) //20ms延时计数器
 140   1          count_20ms--;
 141   1        Heartbeat++;
 142   1        if(Heartbeat>500)//每10秒发送心跳帧
 143   1        {
 144   2          Heartbeat=0;
 145   2          Heart_beat=1;
 146   2        }
 147   1        if(Timer0_start)
 148   1        Times++;
 149   1        if(Times > (50*shijian))
 150   1        {
 151   2          Timer0_start = 0;
 152   2          Times = 0;
 153   2        }
 154   1        TR0=1;//开定时器
 155   1      }
 156          /*******************************************************************************
 157          * 函数名 : GPIO_config
 158          * 描述   : IO口配置函数
 159          * 输入   : 
 160          * 输出   : 
 161          * 返回   : 
 162          * 注意   : 
 163          *******************************************************************************/
 164          void  GPIO_config(void)
 165          {
 166   1          LED=1;
 167   1          RUNING_LED=1;
 168   1      }
 169          
 170          /*******************************************************************************
 171          * 函数名 : Timer0Init
 172          * 描述   : 定时器0初始化，20ms定时
 173          * 输入   : 
 174          * 输出   : 
 175          * 返回   : 
 176          * 注意   : 
 177          *******************************************************************************/
 178          void Timer0Init(void)   //20毫秒@11.0592MHz
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:55:43 PAGE 4   

 179          {
 180   1        AUXR &= 0x7F;   //定时器时钟12T模式
 181   1        TMOD &= 0xF0;   //
 182   1        TMOD |= 0x01;   //设置定时器模式，16位定时器
 183   1        TL0 = 0x00;     //设置定时器初值
 184   1        TH0 = 0xB8;     //设置定时器初值
 185   1        TF0 = 0;        //清TF0标志
 186   1        TR0 = 1;        //定时器0开始计时
 187   1        ET0 = 1;        //使能定时器0中断
 188   1      }
 189          
 190          /*******************************************************************************
 191          * 函数名 : CLR_Buf1
 192          * 描述   : 清除串口2缓存数据
 193          * 输入   : 
 194          * 输出   : 
 195          * 返回   : 
 196          * 注意   : 
 197          *******************************************************************************/
 198          void CLR_Buf1(void)
 199          {
 200   1        u16 k;
 201   1        for(k=0;k<Buf1_Max;k++)      //将缓存内容清零
 202   1        {
 203   2          Uart1_Buf[k] = 0x00;
 204   2        }
 205   1          First_Int = 0;             //接收字符串的起始存储位置
 206   1      }
 207          
 208          /*******************************************************************************
 209          * 函数名 : Wait_CREG
 210          * 描述   : 等待模块注册成功
 211          * 输入   : 
 212          * 输出   : 
 213          * 返回   : 
 214          * 注意   : 
 215          *******************************************************************************/
 216          void Wait_CREG(void)
 217          {
 218   1        u8 i;
 219   1        u8 k;
 220   1        i = 0;
 221   1        CLR_Buf1();
 222   1        while(i == 0)             
 223   1        {
 224   2          CLR_Buf1();        
 225   2          UART1_SendString("AT+CREG?");
 226   2          UART1_SendLR();
 227   2          delay_ms(250);              
 228   2            for(k=0;k<Buf1_Max;k++)           
 229   2            {
 230   3            if(Uart1_Buf[k] == ':')
 231   3            {
 232   4              if((Uart1_Buf[k+4] == '1')||(Uart1_Buf[k+4] == '5'))
 233   4              {
 234   5                i = 1;
 235   5                break;
 236   5              }
 237   4            }
 238   3          }
 239   2        }
 240   1      }
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:55:43 PAGE 5   

 241          
 242          /*******************************************************************************
 243          * 函数名 : Find
 244          * 描述   : 判断缓存中是否含有指定的字符串
 245          * 输入   : 
 246          * 输出   : 
 247          * 返回   : unsigned char:1 找到指定字符，0 未找到指定字符 
 248          * 注意   : 
 249          *******************************************************************************/
 250          
 251          u8 Find(u8 *a)
 252          { 
 253   1        if(strstr(Uart1_Buf,a)!=NULL)
 254   1            return 1;
 255   1        else
 256   1            return 0;
 257   1      }
 258          
 259          /*******************************************************************************
 260          * 函数名 : Second_AT_Command
 261          * 描述   : 发送AT指令函数
 262          * 输入   : 发送数据的指针、发送等待时间(单位：S)
 263          * 输出   : 
 264          * 返回   : 
 265          * 注意   : 
 266          *******************************************************************************/
 267          
 268          void Second_AT_Command(u8 *b,u8 *a,u8 wait_time)         
 269          {
 270   1        u8 i;
 271   1        u8 *c;
 272   1        c = b;                    //保存字符串地址到c
 273   1        CLR_Buf1(); 
 274   1        i = 0;
 275   1        while(i == 0)                    
 276   1        {
 277   2          if(!Find(a)) 
 278   2          {
 279   3            if(Timer0_start == 0)
 280   3            {
 281   4              b = c;              //将字符串地址给b
 282   4              for (b; *b!='\0';b++)
 283   4              {
 284   5                UART1_SendData(*b);
 285   5              }
 286   4              UART1_SendLR(); 
 287   4              Times = 0;
 288   4              shijian = wait_time;
 289   4              Timer0_start = 1;
 290   4             }
 291   3          }
 292   2          else
 293   2          {
 294   3            i = 1;
 295   3            Timer0_start = 0;
 296   3          }
 297   2        }
 298   1        CLR_Buf1(); 
 299   1      }
 300          
 301          /*******************************************************************************
 302          * 函数名 : Set_ATE0
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:55:43 PAGE 6   

 303          * 描述   : 取消回显
 304          * 输入   : 
 305          * 输出   : 
 306          * 返回   : 
 307          * 注意   : 
 308          *******************************************************************************/
 309          void Set_ATE0(void)
 310          {
 311   1        Second_AT_Command("ATE0","OK",3);               //取消回显    
 312   1      }
 313          /*******************************************************************************
 314          * 函数名 : Connect_Server
 315          * 描述   : GPRS连接服务器函数
 316          * 输入   : 
 317          * 输出   : 
 318          * 返回   : 
 319          * 注意   : 
 320          *******************************************************************************/
 321          void Connect_Server(void)
 322          {
 323   1        UART1_SendString("AT+CIPCLOSE=1");  //关闭连接
 324   1        delay_ms(5);
 325   1        Second_AT_Command("AT+CIPSHUT","SHUT OK",2);    //关闭移动场景
 326   1        Second_AT_Command("AT+CGCLASS=\"B\"","OK",2);//设置GPRS移动台类别为B,支持包交换和数据交换 
 327   1        Second_AT_Command("AT+CGDCONT=1,\"IP\",\"CMNET\"","OK",2);//设置PDP上下文,互联网接协议,接入点等信息
 328   1        Second_AT_Command("AT+CGATT=1","OK",2);//附着GPRS业务
 329   1        Second_AT_Command("AT+CIPCSGP=1,\"CMNET\"","OK",2);//设置为GPRS连接模式
 330   1        Second_AT_Command("AT+CIPHEAD=1","OK",2);//设置接收数据显示IP头(方便判断数据来源,仅在单路连接有效)
 331   1        Second_AT_Command(string,"OK",5); 
 332   1        delay_ms(5);
 333   1        CLR_Buf1();
 334   1      }
 335          /*******************************************************************************
 336          * 函数名 : Rec_Server_Data
 337          * 描述   : 接收服务器数据函数
 338          * 输入   : 
 339          * 输出   : 
 340          * 返回   : 
 341          * 注意   : 
 342          *******************************************************************************/
 343          void Rec_Server_Data(void)
 344          {
 345   1        if(strstr(Uart1_Buf,"+IPD")!=NULL)      //若缓存字符串中含有^SISR
 346   1        { 
 347   2          Heartbeat=0;  //清除心跳帧计数器
 348   2          Heart_beat=0;
 349   2          delay_ms(10);
 350   2          if(strstr(Uart1_Buf,"onled")!=NULL)
 351   2          {
 352   3            LED = 0;
 353   3          }
 354   2          else if(strstr(Uart1_Buf,"offled")!=NULL)
 355   2          {
 356   3            LED = 1;
 357   3          }
 358   2          CLR_Buf1();
 359   2          Heart_beat=1;//发送应答数据，告诉服务器收到数据   
 360   2        }
 361   1      }
 362          /*******************************************************************************
 363          * 函数名 : Send_OK
 364          * 描述   : 发送数据应答服务器的指令，该函数在有两功能
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:55:43 PAGE 7   

 365                    1：接收到服务器的数据后，应答服务器
 366                    2：服务器无下发数据时，每隔10秒发送一帧心跳，保持与服务器连接
 367          * 输入   : 
 368          * 输出   : 
 369          * 返回   : 
 370          * 注意   : 
 371          *******************************************************************************/
 372          void Send_OK(void)
 373          {
 374   1        Second_AT_Command("AT+CIPSEND",">",2);
 375   1        Second_AT_Command("OK\32\0","SEND OK",8);;      //回复OK
 376   1        delay_ms(10);
 377   1        CLR_Buf1(); 
 378   1      }
 379          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    801    ----
   CONSTANT SIZE    =    219    ----
   XDATA SIZE       =    200    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     10      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
