C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:59:11 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\Output\main.obj
COMPILER INVOKED BY: E:\mcu_keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND PRINT(..\Listing\main.lst) TABS(2) OBJ
                    -ECT(..\Output\main.obj)

line level    source

   1          /**********************************************************************************
   2           * 工程名  :拨打电话
   3           * 描述    :通过C51开发板控制模块接听电话
   4           * 实验平台:C51
   5           * 库版本  :
   6          
   7           * 硬件连接说明
   8             使用单片串口与GPRS模块通信 
   9             C51        GPRS模块
  10             P30 (RXD)->RXD
  11             P31 (TXD)->TXD
  12             GND      ->GND
  13             P34      ->PWR
  14             PWR：这个引脚是控制模块启动，V1.2版本已经有自启动电路所以不必接，老版本可以通过程序
  15                  控制这个引脚让模块开机。当然也可以使用按键手动开机。
  16          
  17           * 软件功能说明
  18             板子上电后运行指示灯RUNING_LED会以一秒的频率闪烁
  19          **********************************************************************************/
  20          #include "config.h"
  21          #include "string.h"
  22          #include "delay.h"
  23          #include "uart.h"
  24          
  25          #define Automatic_Startup 1     //定义自启动 V1.2版本起有自启动功能
  26          
  27          #define Buf1_Max 200            //串口1缓存长度
  28          /*************  本地常量声明  **************/
  29          sbit RUNING_LED = P1^2;         //运行指示灯
  30          sbit LED        = P3^3;         //控制指示灯
  31          sbit PWR_MG323  = P3^4;         //启动MG323控制引脚
  32          
  33          
  34          /*************  本地变量声明  **************/
  35          
  36          xdata u8 Uart1_Buf[Buf1_Max];   //串口1接收缓存
  37          
  38          u8 Times=0,First_Int = 0,shijian=0;
  39          bdata u8 Flag;              //定时器标志位
  40          sbit Timer0_start =Flag^0;  //定时器0延时启动计数器
  41          
  42          
  43          
  44          /*************  本地函数声明  **************/
  45          void GPIO_config(void); //引脚初始化
  46          void Timer0Init(void);  //定时器0初始化
  47          void CLR_Buf1(void);    //清串口接收缓存
  48          u8 Find(u8 *a);         //查找字符串
  49          void Wait_CREG(void);   //查询等待模块注册成功
  50          
  51          /*************  外部函数和变量声明*****************/
  52          
  53          
  54          
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:59:11 PAGE 2   

  55          
  56          /*******************************************************************************
  57          * 函数名 : main 
  58          * 描述   : 主函数
  59          * 输入   : 
  60          * 输出   : 
  61          * 返回   : 
  62          * 注意   : 串口波特率是9600，GPRS模块默认波特率是115200，需要自己通过串口助手修改
  63                     为9600方可使用。
  64          *******************************************************************************/
  65          void main(void)
  66          {
  67   1        Timer0Init();  //初始化定时器0
  68   1        GPIO_config();
  69   1        EA=1; //开总中断
  70   1        #if Automatic_Startup==0 //不使用自启动
                PWR_MG323=0;
                delay_ms(150);//延时150*20ms=3s
                PWR_MG323=1;
                #endif
  75   1        Uart1Init();  //初始化串口9600
  76   1        Wait_CREG();  //查询模块是否注册成功
  77   1      
  78   1        while(1)
  79   1        {
  80   2            if(Find("CRING")|Find("RING"))  //有新来电
  81   2            {
  82   3                CLR_Buf1();
  83   3                UART1_SendString("ATA\r\n");//接听来电
  84   3            }
  85   2            delay_ms(50);//每秒查询一次 
  86   2        }
  87   1        
  88   1      }
  89          
  90          /*******************************************************************************
  91          * 函数名 : Uart1 
  92          * 描述   : 串口1中断服务入口函数
  93          * 输入   : 
  94          * 输出   : 
  95          * 返回   : 
  96          * 注意   : 
  97          *******************************************************************************/
  98          void Uart1() interrupt 4
  99          {
 100   1          if (RI)
 101   1          {
 102   2            RI = 0;                 //清除RI位
 103   2            Uart1_Buf[First_Int] = SBUF;      //将接收到的字符串存到缓存中
 104   2            First_Int++;                      //缓存指针向后移动
 105   2            if(First_Int > Buf1_Max)          //如果缓存满,将缓存指针指向缓存的首地址
 106   2            {
 107   3              First_Int = 0;
 108   3            }
 109   2          }
 110   1          if (TI)
 111   1          {
 112   2              TI = 0;                 //清除TI位
 113   2          }
 114   1      }
 115          /*******************************************************************************
 116          * 函数名 : Timer0_ISR
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:59:11 PAGE 3   

 117          * 描述   : 定时器0中断服务入口函数,20ms中断一次
 118          * 输入   : 
 119          * 输出   : 
 120          * 返回   : 
 121          * 注意   : 
 122          *******************************************************************************/
 123          void Timer0_ISR() interrupt 1
 124          {
 125   1        static u8 Time_count=0;
 126   1        TL0 = 0x00;     //重置定时器初值
 127   1        TH0 = 0xB8;     //重置定时器初值
 128   1        TR0=0;//关定时器
 129   1        Time_count++;
 130   1        if(count_20ms) //20ms延时计数器
 131   1          count_20ms--;
 132   1        if(Time_count>=50)
 133   1        {
 134   2          Time_count = 0;
 135   2          RUNING_LED =~RUNING_LED;
 136   2        }
 137   1      
 138   1        TR0=1;//开定时器
 139   1      }
 140          
 141          /*******************************************************************************
 142          * 函数名 : GPIO_config
 143          * 描述   : IO口配置函数
 144          * 输入   : 
 145          * 输出   : 
 146          * 返回   : 
 147          * 注意   : 
 148          *******************************************************************************/
 149          void  GPIO_config(void)
 150          {
 151   1          LED=0;
 152   1          RUNING_LED=0;
 153   1      }
 154          /*******************************************************************************
 155          * 函数名 : Timer0Init
 156          * 描述   : 定时器0初始化，20ms定时
 157          * 输入   : 
 158          * 输出   : 
 159          * 返回   : 
 160          * 注意   : 
 161          *******************************************************************************/
 162          void Timer0Init(void)   //20毫秒@11.0592MHz
 163          {
 164   1        AUXR &= 0x7F;   //定时器时钟12T模式
 165   1        TMOD &= 0xF0;   //
 166   1        TMOD |= 0x01;   //设置定时器模式，16位定时器
 167   1        TL0 = 0x00;     //设置定时器初值
 168   1        TH0 = 0xB8;     //设置定时器初值
 169   1        TF0 = 0;        //清TF0标志
 170   1        TR0 = 1;        //定时器0开始计时
 171   1        ET0 = 1;        //使能定时器0中断
 172   1      }
 173          /*******************************************************************************
 174          * 函数名 : CLR_Buf1
 175          * 描述   : 清除串口2缓存数据
 176          * 输入   : 
 177          * 输出   : 
 178          * 返回   : 
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:59:11 PAGE 4   

 179          * 注意   : 
 180          *******************************************************************************/
 181          void CLR_Buf1(void)
 182          {
 183   1        u16 k;
 184   1        for(k=0;k<Buf1_Max;k++)      //将缓存内容清零
 185   1        {
 186   2          Uart1_Buf[k] = 0x00;
 187   2        }
 188   1          First_Int = 0;              //接收字符串的起始存储位置
 189   1      }
 190          
 191          /*******************************************************************************
 192          * 函数名 : Find
 193          * 描述   : 判断缓存中是否含有指定的字符串
 194          * 输入   : 
 195          * 输出   : 
 196          * 返回   : unsigned char:1 找到指定字符，0 未找到指定字符 
 197          * 注意   : 
 198          *******************************************************************************/
 199          
 200          u8 Find(u8 *a)
 201          { 
 202   1        if(strstr(Uart1_Buf,a)!=NULL)
 203   1            return 1;
 204   1        else
 205   1            return 0;
 206   1      }
 207          
 208          /*******************************************************************************
 209          * 函数名 : Wait_CREG
 210          * 描述   : 等待模块注册成功
 211          * 输入   : 
 212          * 输出   : 
 213          * 返回   : 
 214          * 注意   : 
 215          *******************************************************************************/
 216          void Wait_CREG(void)
 217          {
 218   1        u8 i;
 219   1        u8 k;
 220   1        i = 0;
 221   1        CLR_Buf1();
 222   1        while(i == 0)             
 223   1        {
 224   2          CLR_Buf1();        
 225   2          UART1_SendString("AT+CREG?"); //查询模块网络注册状态
 226   2          UART1_SendLR();
 227   2          delay_ms(250);              
 228   2            for(k=0;k<Buf1_Max;k++)           
 229   2            {
 230   3            if(Uart1_Buf[k] == ':')
 231   3            {
 232   4              if((Uart1_Buf[k+4] == '1')||(Uart1_Buf[k+4] == '5')) //说明注册成功
 233   4              {
 234   5                i = 1;
 235   5                break;
 236   5              }
 237   4            }
 238   3          }
 239   2        }
 240   1      }
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:59:11 PAGE 5   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    318    ----
   CONSTANT SIZE    =     26    ----
   XDATA SIZE       =    200    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
