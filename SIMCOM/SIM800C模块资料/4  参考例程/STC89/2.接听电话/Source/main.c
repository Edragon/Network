/**********************************************************************************
 * 工程名  :拨打电话
 * 描述    :通过C51开发板控制模块接听电话
 * 实验平台:C51
 * 库版本  :

 * 硬件连接说明
	 使用单片串口与GPRS模块通信 
	 C51        GPRS模块
	 P30 (RXD)->RXD
	 P31 (TXD)->TXD
	 GND	    ->GND
	 P34      ->PWR
   PWR：这个引脚是控制模块启动，V1.2版本已经有自启动电路所以不必接，老版本可以通过程序
        控制这个引脚让模块开机。当然也可以使用按键手动开机。

 * 软件功能说明
   板子上电后运行指示灯RUNING_LED会以一秒的频率闪烁
**********************************************************************************/
#include "config.h"
#include "string.h"
#include "delay.h"
#include "uart.h"

#define Automatic_Startup 1     //定义自启动 V1.2版本起有自启动功能

#define Buf1_Max 200 					  //串口1缓存长度
/*************	本地常量声明	**************/
sbit RUNING_LED = P1^2;					//运行指示灯
sbit LED  			= P3^3;					//控制指示灯
sbit PWR_MG323 	= P3^4;					//启动MG323控制引脚


/*************  本地变量声明	**************/

xdata u8 Uart1_Buf[Buf1_Max];   //串口1接收缓存

u8 Times=0,First_Int = 0,shijian=0;
bdata u8 Flag;							//定时器标志位
sbit Timer0_start =Flag^0;	//定时器0延时启动计数器



/*************	本地函数声明	**************/
void GPIO_config(void); //引脚初始化
void Timer0Init(void);  //定时器0初始化
void CLR_Buf1(void);    //清串口接收缓存
u8 Find(u8 *a);         //查找字符串
void Wait_CREG(void);   //查询等待模块注册成功

/*************  外部函数和变量声明*****************/




/*******************************************************************************
* 函数名 : main 
* 描述   : 主函数
* 输入   : 
* 输出   : 
* 返回   : 
* 注意   : 串口波特率是9600，GPRS模块默认波特率是115200，需要自己通过串口助手修改
				   为9600方可使用。
*******************************************************************************/
void main(void)
{
  Timer0Init();  //初始化定时器0
	GPIO_config();
	EA=1;	//开总中断
	#if Automatic_Startup==0 //不使用自启动
	PWR_MG323=0;
	delay_ms(150);//延时150*20ms=3s
	PWR_MG323=1;
	#endif
	Uart1Init();  //初始化串口9600
	Wait_CREG();  //查询模块是否注册成功

	while(1)
	{
		  if(Find("CRING")|Find("RING"))  //有新来电
			{
          CLR_Buf1();
				  UART1_SendString("ATA\r\n");//接听来电
			}
			delay_ms(50);//每秒查询一次	
	}
	
}

/*******************************************************************************
* 函数名 : Uart1 
* 描述   : 串口1中断服务入口函数
* 输入   : 
* 输出   : 
* 返回   : 
* 注意   : 
*******************************************************************************/
void Uart1() interrupt 4
{
    if (RI)
    {
      RI = 0;                 //清除RI位
			Uart1_Buf[First_Int] = SBUF;  	  //将接收到的字符串存到缓存中
			First_Int++;                			//缓存指针向后移动
			if(First_Int > Buf1_Max)       		//如果缓存满,将缓存指针指向缓存的首地址
			{
				First_Int = 0;
			}
    }
    if (TI)
    {
        TI = 0;                 //清除TI位
    }
}
/*******************************************************************************
* 函数名 : Timer0_ISR
* 描述   : 定时器0中断服务入口函数,20ms中断一次
* 输入   : 
* 输出   : 
* 返回   : 
* 注意   : 
*******************************************************************************/
void Timer0_ISR() interrupt 1
{
	static u8 Time_count=0;
	TL0 = 0x00;		  //重置定时器初值
	TH0 = 0xB8;		  //重置定时器初值
	TR0=0;//关定时器
	Time_count++;
	if(count_20ms) //20ms延时计数器
		count_20ms--;
	if(Time_count>=50)
	{
		Time_count = 0;
		RUNING_LED =~RUNING_LED;
	}

	TR0=1;//开定时器
}

/*******************************************************************************
* 函数名 : GPIO_config
* 描述   : IO口配置函数
* 输入   : 
* 输出   : 
* 返回   : 
* 注意   : 
*******************************************************************************/
void	GPIO_config(void)
{
		LED=0;
		RUNING_LED=0;
}
/*******************************************************************************
* 函数名 : Timer0Init
* 描述   : 定时器0初始化，20ms定时
* 输入   : 
* 输出   : 
* 返回   : 
* 注意   : 
*******************************************************************************/
void Timer0Init(void)		//20毫秒@11.0592MHz
{
	AUXR &= 0x7F;		//定时器时钟12T模式
	TMOD &= 0xF0;		//
	TMOD |= 0x01;		//设置定时器模式，16位定时器
	TL0 = 0x00;		  //设置定时器初值
	TH0 = 0xB8;		  //设置定时器初值
	TF0 = 0;		    //清TF0标志
	TR0 = 1;		    //定时器0开始计时
	ET0 = 1;    	  //使能定时器0中断
}
/*******************************************************************************
* 函数名 : CLR_Buf1
* 描述   : 清除串口2缓存数据
* 输入   : 
* 输出   : 
* 返回   : 
* 注意   : 
*******************************************************************************/
void CLR_Buf1(void)
{
	u16 k;
	for(k=0;k<Buf1_Max;k++)      //将缓存内容清零
	{
		Uart1_Buf[k] = 0x00;
	}
    First_Int = 0;              //接收字符串的起始存储位置
}

/*******************************************************************************
* 函数名 : Find
* 描述   : 判断缓存中是否含有指定的字符串
* 输入   : 
* 输出   : 
* 返回   : unsigned char:1 找到指定字符，0 未找到指定字符 
* 注意   : 
*******************************************************************************/

u8 Find(u8 *a)
{ 
  if(strstr(Uart1_Buf,a)!=NULL)
	    return 1;
	else
			return 0;
}

/*******************************************************************************
* 函数名 : Wait_CREG
* 描述   : 等待模块注册成功
* 输入   : 
* 输出   : 
* 返回   : 
* 注意   : 
*******************************************************************************/
void Wait_CREG(void)
{
	u8 i;
	u8 k;
	i = 0;
	CLR_Buf1();
  while(i == 0)        			
	{
		CLR_Buf1();        
		UART1_SendString("AT+CREG?"); //查询模块网络注册状态
		UART1_SendLR();
		delay_ms(250);  						
	    for(k=0;k<Buf1_Max;k++)      			
    	{
			if(Uart1_Buf[k] == ':')
			{
				if((Uart1_Buf[k+4] == '1')||(Uart1_Buf[k+4] == '5')) //说明注册成功
				{
					i = 1;
				  break;
				}
			}
		}
	}
}
