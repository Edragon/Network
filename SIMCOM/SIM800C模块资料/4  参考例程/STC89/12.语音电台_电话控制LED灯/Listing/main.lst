C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:57:06 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\Output\main.obj
COMPILER INVOKED BY: E:\mcu_keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND PRINT(..\Listing\main.lst) TABS(2) OBJ
                    -ECT(..\Output\main.obj)

line level    source

   1          /**********************************************************************************
   2           * 工程名  :短信控制LED
   3           * 描述    :通过短信控制开发板的LED
   4           * 实验平台:C51
   5           * 库版本  :
   6          
   7           * 硬件连接说明
   8             使用单片串口与GPRS模块通信 
   9             C51        GPRS模块
  10             P30 (RXD)->RXD
  11             P31 (TXD)->TXD
  12             GND      ->GND
  13          
  14           * 软件功能说明
  15             板子上电后运行指示灯RUNING_LED会以一秒的频率闪烁
  16             手机发送“onled”点亮LED；
  17             手机发送“offled”熄灭LED；
  18          **********************************************************************************/
  19          #include "config.h"
  20          #include "string.h"
  21          #include "delay.h"
  22          #include "uart.h"
  23          
  24          
  25          
  26          #define Buf1_Max 200            //串口1缓存长度
  27          /*************  本地常量声明  **************/
  28          sbit RUNING_LED = P1^2;         //运行指示灯
  29          sbit LED        = P1^3;         //控制指示灯
  30          
  31          
  32          /*************  本地变量声明  **************/
  33          xdata u8 Uart1_Buf[Buf1_Max];
  34          
  35          u8 Times=0,First_Int = 0,shijian=0;
  36          
  37          bdata u8 Flag;//定时器标志位
  38          sbit Timer0_start =Flag^0;  //定时器0延时启动计数器
  39          
  40          
  41          
  42          /*************  本地函数声明  **************/
  43          void GPIO_config(void);   //引脚初始化
  44          void Timer0Init(void);    //定时器0初始化
  45          void CLR_Buf1(void);      //清串口接收缓存
  46          u8 Find(u8 *a);           //查找字符串
  47          void Second_AT_Command(u8 *b,u8 *a,u8 wait_time);//发送指令
  48          void Wait_CREG(void);     //查询等待模块注册成功
  49          void Set_TTS_Mode(void); //设置短信为TEXT模式
  50          void Check_New_Message(void);  //查询新短信
  51          
  52          
  53          /*************  外部函数和变量声明*****************/
  54          
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:57:06 PAGE 2   

  55          
  56          
  57          
  58          /*******************************************************************************
  59          * 函数名 : main 
  60          * 描述   : 主函数
  61          * 输入   : 
  62          * 输出   : 
  63          * 返回   : 
  64          * 注意   : 串口波特率是9600，GPRS模块默认波特率是115200，需要自己通过串口助手修改
  65                     为9600方可使用。 
  66                     程序会删除手机卡上的短信，请注意
  67          *******************************************************************************/
  68          void main(void)
  69          {
  70   1        Timer0Init();  //初始化定时器0
  71   1        GPIO_config();
  72   1        EA=1; //开总中断
  73   1        Uart1Init();    //初始化串口9600
  74   1        Wait_CREG();    //查询等待模块注册成功
  75   1        Set_TTS_Mode();
  76   1        while(1)
  77   1        {
  78   2          Check_New_Message();
  79   2        }
  80   1        
  81   1      }
  82          
  83          /*******************************************************************************
  84          * 函数名 : Uart1 
  85          * 描述   : 串口1中断服务入口函数
  86          * 输入   : 
  87          * 输出   : 
  88          * 返回   : 
  89          * 注意   : 
  90          *******************************************************************************/
  91          void Uart1() interrupt 4
  92          {
  93   1          if (RI)
  94   1          {
  95   2            RI = 0;                           //清除RI位
  96   2            Uart1_Buf[First_Int] = SBUF;      //将接收到的字符串存到缓存中
  97   2            First_Int++;                      //缓存指针向后移动
  98   2            if(First_Int > Buf1_Max)          //如果缓存满,将缓存指针指向缓存的首地址
  99   2            {
 100   3              First_Int = 0;
 101   3            }
 102   2          }
 103   1          if (TI)
 104   1          {
 105   2              TI = 0;                          //清除TI位
 106   2          }
 107   1      }
 108          
 109          /*******************************************************************************
 110          * 函数名 : Timer0_ISR
 111          * 描述   : 定时器0中断服务入口函数,20ms中断一次
 112          * 输入   : 
 113          * 输出   : 
 114          * 返回   : 
 115          * 注意   : 
 116          *******************************************************************************/
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:57:06 PAGE 3   

 117          void Timer0_ISR() interrupt 1
 118          {
 119   1        static u8 Time_count=0; 
 120   1        TR0=0;//关定时器
 121   1        TL0 = 0x00;   //重设定时器初值
 122   1        TH0 = 0xB8;   //重设定时器初值
 123   1        Time_count++;
 124   1        if(Time_count>=50)
 125   1        {
 126   2          Time_count = 0;
 127   2          RUNING_LED =~RUNING_LED;
 128   2        }
 129   1        if(count_20ms) //20ms延时计数器
 130   1          count_20ms--;
 131   1        if(Timer0_start)
 132   1          Times++;
 133   1        if(Times > (50*shijian))
 134   1        {
 135   2          Timer0_start = 0;
 136   2          Times = 0;
 137   2        }
 138   1        TR0=1;//开定时器
 139   1      }
 140          /*******************************************************************************
 141          * 函数名 : GPIO_config
 142          * 描述   : IO口配置函数
 143          * 输入   : 
 144          * 输出   : 
 145          * 返回   : 
 146          * 注意   : 
 147          *******************************************************************************/
 148          void  GPIO_config(void)
 149          {
 150   1          LED=1;
 151   1          RUNING_LED=1;
 152   1      }
 153          /*******************************************************************************
 154          * 函数名 : Timer0Init
 155          * 描述   : 定时器0初始化，20ms定时
 156          * 输入   : 
 157          * 输出   : 
 158          * 返回   : 
 159          * 注意   : 
 160          *******************************************************************************/
 161          void Timer0Init(void)   //20毫秒@11.0592MHz
 162          {
 163   1        AUXR &= 0x7F;   //定时器时钟12T模式
 164   1        TMOD &= 0xF0;   //
 165   1        TMOD |= 0x01;   //设置定时器模式，16位定时器
 166   1        TL0 = 0x00;     //设置定时器初值
 167   1        TH0 = 0xB8;     //设置定时器初值
 168   1        TF0 = 0;        //清TF0标志
 169   1        TR0 = 1;        //定时器0开始计时
 170   1        ET0 = 1;        //使能定时器0中断
 171   1      }
 172          /*******************************************************************************
 173          * 函数名 : CLR_Buf1
 174          * 描述   : 清除串口2缓存数据
 175          * 输入   : 
 176          * 输出   : 
 177          * 返回   : 
 178          * 注意   : 
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:57:06 PAGE 4   

 179          *******************************************************************************/
 180          void CLR_Buf1(void)
 181          {
 182   1        u16 k;
 183   1        for(k=0;k<Buf1_Max;k++)      //将缓存内容清零
 184   1        {
 185   2          Uart1_Buf[k] = 0x00;
 186   2        }
 187   1          First_Int = 0;              //接收字符串的起始存储位置
 188   1      }
 189          
 190          /*******************************************************************************
 191          * 函数名 : Find
 192          * 描述   : 判断缓存中是否含有指定的字符串
 193          * 输入   : 
 194          * 输出   : 
 195          * 返回   : unsigned char:1 找到指定字符，0 未找到指定字符 
 196          * 注意   : 
 197          *******************************************************************************/
 198          
 199          u8 Find(u8 *a)
 200          { 
 201   1        if(strstr(Uart1_Buf,a)!=NULL)
 202   1            return 1;
 203   1        else
 204   1            return 0;
 205   1      }
 206          
 207          /*******************************************************************************
 208          * 函数名 : Second_AT_Command
 209          * 描述   : 发送AT指令函数
 210          * 输入   : 发送数据的指针、希望收到的应答、发送等待时间(单位：S)
 211          * 输出   : 
 212          * 返回   : 
 213          * 注意   : 
 214          *******************************************************************************/
 215          
 216          void Second_AT_Command(u8 *b,u8 *a,u8 wait_time)         
 217          {
 218   1        u8 i;
 219   1        u8 *c;
 220   1        c = b;                    //保存字符串地址到c
 221   1        CLR_Buf1(); 
 222   1        i = 0;
 223   1        while(i == 0)                    
 224   1        {
 225   2          if(!Find(a))            //查找需要应答的字符
 226   2          {
 227   3            if(Timer0_start == 0)
 228   3            {
 229   4              b = c;              //将字符串地址给b
 230   4              for (b; *b!='\0';b++)
 231   4              {
 232   5                UART1_SendData(*b);
 233   5              }
 234   4              UART1_SendLR(); 
 235   4              Times = 0;
 236   4              shijian = wait_time;
 237   4              Timer0_start = 1;
 238   4             }
 239   3          }
 240   2          else
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:57:06 PAGE 5   

 241   2          {
 242   3            i = 1;
 243   3            Timer0_start = 0;
 244   3          }
 245   2        }
 246   1        CLR_Buf1(); 
 247   1      }
 248          
 249          /*******************************************************************************
 250          * 函数名 : Set_TTS_Mode
 251          * 描述   : 设置TTS和DTMF模式
 252          * 输入   : 
 253          * 输出   : 
 254          * 返回   : 
 255          * 注意   : 
 256          *******************************************************************************/
 257          void Set_TTS_Mode(void)
 258          {
 259   1        Second_AT_Command("ATE0","OK",3);                   //取消回显  
 260   1        Second_AT_Command("AT+CTTSPARAM=100,0,50,50,1","OK",3);         //设置TTS参数
 261   1        Second_AT_Command("AT+DDET=1","OK",3);                    //打开DTMF解码
 262   1      }
 263          
 264          /*******************************************************************************
 265          * 函数名 : Check_Message_rec
 266          * 描述   : 检查是否有新信息，并执行信息内容指令
 267          * 输入   : 
 268          * 输出   : 
 269          * 返回   : 
 270          * 注意   : 
 271          *******************************************************************************/
 272          
 273          void Check_New_Message(void)
 274          {
 275   1        static u8 Ring_flag=0;//来电标志
 276   1          if(Ring_flag==0)
 277   1          {
 278   2              if(strstr(Uart1_Buf,"RING")!=NULL)      //若缓存字符串中含有"+CMT"就表示有新的短信
 279   2              {
 280   3                  Second_AT_Command("ATA","OK",3);             //接听电话
 281   3                  Ring_flag=1;
 282   3                  Second_AT_Command("AT+CTTS=2,\"欢迎使用泥人电子语音测试程序\"","OK",3); //播放语音测试
 283   3                  CLR_Buf1();
 284   3              }
 285   2          }else
 286   1          {
 287   2              if(strstr(Uart1_Buf,"+DTMF:")!=NULL)      //有按键按下
 288   2              {
 289   3                  if(strstr(Uart1_Buf,"1")!=NULL)//打开LED
 290   3                  {
 291   4                      LED=1;
 292   4                      Second_AT_Command("AT+CTTS=2,\"打开LED\"","OK",3); //播放语音测试
 293   4                  }else
 294   3                  if(strstr(Uart1_Buf,"2")!=NULL)//关闭第一路
 295   3                  {
 296   4                      LED=0;
 297   4                      Second_AT_Command("AT+CTTS=2,\"关闭LED\"","OK",3); //播放语音测试
 298   4                  }
 299   3                  CLR_Buf1();
 300   3              }else
 301   2              if(strstr(Uart1_Buf,"NO CARRIER")!=NULL)
 302   2              {
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:57:06 PAGE 6   

 303   3                  Ring_flag=0;
 304   3                  CLR_Buf1();
 305   3              }
 306   2          }
 307   1      }
 308          
 309          /*******************************************************************************
 310          * 函数名 : Wait_CREG
 311          * 描述   : 等待模块注册成功
 312          * 输入   : 
 313          * 输出   : 
 314          * 返回   : 
 315          * 注意   : 
 316          *******************************************************************************/
 317          void Wait_CREG(void)
 318          {
 319   1        u8 i;
 320   1        u8 k;
 321   1        i = 0;
 322   1        CLR_Buf1();
 323   1        while(i == 0)             
 324   1        {
 325   2          CLR_Buf1();        
 326   2          UART1_SendString("AT+CREG?");//查询模块网络注册状态
 327   2          UART1_SendLR();
 328   2          delay_ms(500);              
 329   2          for(k=0;k<Buf1_Max;k++)           
 330   2          {
 331   3          if(Uart1_Buf[k] == ':')
 332   3          {
 333   4            if((Uart1_Buf[k+4] == '1')||(Uart1_Buf[k+4] == '5')) //表明网络注册成功
 334   4            {
 335   5              i = 1;
 336   5              break;
 337   5            }
 338   4          }
 339   3         }
 340   2        }
 341   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    719    ----
   CONSTANT SIZE    =    166    ----
   XDATA SIZE       =    200    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
