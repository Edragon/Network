C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:55:59 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\Output\main.obj
COMPILER INVOKED BY: E:\mcu_keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND PRINT(..\Listing\main.lst) TABS(2) OBJ
                    -ECT(..\Output\main.obj)

line level    source

   1          /**********************************************************************************
   2           * 工程名  :GPRS
   3           * 描述    :测试GPRS连接，并且服务器可以通过GPRS控制LED
   4           * 实验平台:C51
   5           * 库版本  :
   6          
   7           * 硬件连接说明
   8             使用单片串口与GPRS模块通信 
   9             C51        GPRS模块
  10             P30 (RXD)->RXD
  11             P31 (TXD)->TXD
  12             GND      ->GND
  13          
  14          
  15           * 软件功能说明
  16             板子上电后运行指示灯RUNING_LED会以一秒的频率闪烁
  17             服务器发送“onled”点亮LED；
  18             服务器发送“offled”熄灭LED；
  19             单片机每隔10秒会向服务器发送心跳帧“OK”
  20          **********************************************************************************/
  21          #include "config.h"
  22          #include "string.h"
  23          #include "delay.h"
  24          #include "uart.h"
  25          
  26          
  27          #define Buf1_Max 200            //串口2缓存长度
  28          /*************  本地常量声明  **************/
  29          
  30          const u8 *string = "AT+CIPSTART=\"UDP\",\"nirenelec.oicp.net\",9015"; //IP登录服务器
  31          sbit RUNING_LED = P1^1;         //运行指示灯
  32          sbit LED        = P1^2;         //控制指示灯
  33          
  34          
  35          /*************  本地变量声明  **************/
  36          xdata u8 Uart1_Buf[Buf1_Max];
  37          
  38          u8 Times=0,First_Int = 0,shijian=0;
  39          u16 Heartbeat=0;
  40          //u8 Time_count=0;
  41          bdata u8 Flag;//定时器标志位
  42          sbit Timer0_start =Flag^0;  //定时器0延时启动计数器
  43          sbit Heart_beat   =Flag^1;  //发送心跳帧标志位
  44          
  45          /*************  本地函数声明  **************/
  46          void GPIO_config(void);
  47          void Timer0Init(void);
  48          void CLR_Buf2(void);
  49          u8 Find(u8 *a);
  50          void Second_AT_Command(u8 *b,u8 *a,u8 wait_time);
  51          void Set_ATE0(void);
  52          void Connect_Server(void);
  53          void Rec_Server_Data(void);
  54          void Wait_CREG(void);
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:55:59 PAGE 2   

  55          void Send_OK(void);
  56          
  57          /*************  外部函数和变量声明*****************/
  58          
  59          
  60          
  61          
  62          /*******************************************************************************
  63          * 函数名 : main 
  64          * 描述   : 主函数
  65          * 输入   : 
  66          * 输出   : 
  67          * 返回   : 
  68          * 注意   : 串口波特率是9600，GPRS模块默认波特率是115200，需要自己通过串口助手修改
  69                     为9600方可使用。
  70          *******************************************************************************/
  71          void main(void)
  72          {
  73   1        Timer0Init();  //初始化定时器0
  74   1        GPIO_config();
  75   1        EA=1; //开总中断
  76   1        Uart1Init();    //初始化串口9600
  77   1        Wait_CREG();    //查询等待模块注册成功
  78   1        Set_ATE0();     //取消回显
  79   1        Connect_Server();//配置GPRS服务
  80   1        while(1)
  81   1        {
  82   2          Rec_Server_Data(); //接收服务器下发的数据，并处理
  83   2          
  84   2          if(Heart_beat)     //发送心跳帧
  85   2          {
  86   3            Send_OK();
  87   3            Heart_beat=0;
  88   3          }
  89   2        }
  90   1      }
  91          
  92          /*******************************************************************************
  93          * 函数名 : Uart1 
  94          * 描述   : 串口1中断服务入口函数
  95          * 输入   : 
  96          * 输出   : 
  97          * 返回   : 
  98          * 注意   : 
  99          *******************************************************************************/
 100          void Uart1() interrupt 4
 101          {
 102   1          if (RI)
 103   1          {
 104   2            RI = 0;                           //清除RI位
 105   2            Uart1_Buf[First_Int] = SBUF;      //将接收到的字符串存到缓存中
 106   2            First_Int++;                      //缓存指针向后移动
 107   2            if(First_Int > Buf1_Max)          //如果缓存满,将缓存指针指向缓存的首地址
 108   2            {
 109   3              First_Int = 0;
 110   3            }
 111   2          }
 112   1          if (TI)
 113   1          {
 114   2              TI = 0;                          //清除TI位
 115   2          }
 116   1      }
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:55:59 PAGE 3   

 117          
 118          /*******************************************************************************
 119          * 函数名 : Timer0_ISR
 120          * 描述   : 定时器0中断服务入口函数,20ms中断一次
 121          * 输入   : 
 122          * 输出   : 
 123          * 返回   : 
 124          * 注意   : 
 125          *******************************************************************************/
 126          void Timer0_ISR() interrupt 1
 127          {
 128   1        static u8 Time_count=0; 
 129   1        TR0=0;//关定时器
 130   1        TL0 = 0x00;   //重设定时器初值
 131   1        TH0 = 0xB8;   //重设定时器初值
 132   1        Time_count++;
 133   1        if(Time_count>=50)//1秒运行指示灯闪烁
 134   1        {
 135   2          Time_count = 0;
 136   2          RUNING_LED =~RUNING_LED;
 137   2        }
 138   1        if(count_20ms) //20ms延时计数器
 139   1          count_20ms--;
 140   1        Heartbeat++;
 141   1        if(Heartbeat>500)//每10秒发送心跳帧
 142   1        {
 143   2          Heartbeat=0;
 144   2          Heart_beat=1;
 145   2        }
 146   1        if(Timer0_start)
 147   1        Times++;
 148   1        if(Times > (50*shijian))
 149   1        {
 150   2          Timer0_start = 0;
 151   2          Times = 0;
 152   2        }
 153   1        TR0=1;//开定时器
 154   1      }
 155          /*******************************************************************************
 156          * 函数名 : GPIO_config
 157          * 描述   : IO口配置函数
 158          * 输入   : 
 159          * 输出   : 
 160          * 返回   : 
 161          * 注意   : 
 162          *******************************************************************************/
 163          void  GPIO_config(void)
 164          {
 165   1          LED=1;
 166   1          RUNING_LED=1;
 167   1      }
 168          
 169          /*******************************************************************************
 170          * 函数名 : Timer0Init
 171          * 描述   : 定时器0初始化，20ms定时
 172          * 输入   : 
 173          * 输出   : 
 174          * 返回   : 
 175          * 注意   : 
 176          *******************************************************************************/
 177          void Timer0Init(void)   //20毫秒@11.0592MHz
 178          {
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:55:59 PAGE 4   

 179   1        AUXR &= 0x7F;   //定时器时钟12T模式
 180   1        TMOD &= 0xF0;   //
 181   1        TMOD |= 0x01;   //设置定时器模式，16位定时器
 182   1        TL0 = 0x00;     //设置定时器初值
 183   1        TH0 = 0xB8;     //设置定时器初值
 184   1        TF0 = 0;        //清TF0标志
 185   1        TR0 = 1;        //定时器0开始计时
 186   1        ET0 = 1;        //使能定时器0中断
 187   1      }
 188          
 189          /*******************************************************************************
 190          * 函数名 : CLR_Buf1
 191          * 描述   : 清除串口2缓存数据
 192          * 输入   : 
 193          * 输出   : 
 194          * 返回   : 
 195          * 注意   : 
 196          *******************************************************************************/
 197          void CLR_Buf1(void)
 198          {
 199   1        u16 k;
 200   1        for(k=0;k<Buf1_Max;k++)      //将缓存内容清零
 201   1        {
 202   2          Uart1_Buf[k] = 0x00;
 203   2        }
 204   1          First_Int = 0;             //接收字符串的起始存储位置
 205   1      }
 206          
 207          /*******************************************************************************
 208          * 函数名 : Wait_CREG
 209          * 描述   : 等待模块注册成功
 210          * 输入   : 
 211          * 输出   : 
 212          * 返回   : 
 213          * 注意   : 
 214          *******************************************************************************/
 215          void Wait_CREG(void)
 216          {
 217   1        u8 i;
 218   1        u8 k;
 219   1        i = 0;
 220   1        CLR_Buf1();
 221   1        while(i == 0)             
 222   1        {
 223   2          CLR_Buf1();        
 224   2          UART1_SendString("AT+CREG?");
 225   2          UART1_SendLR();
 226   2          delay_ms(250);              
 227   2            for(k=0;k<Buf1_Max;k++)           
 228   2            {
 229   3            if(Uart1_Buf[k] == ':')
 230   3            {
 231   4              if((Uart1_Buf[k+4] == '1')||(Uart1_Buf[k+4] == '5'))
 232   4              {
 233   5                i = 1;
 234   5                break;
 235   5              }
 236   4            }
 237   3          }
 238   2        }
 239   1      }
 240          
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:55:59 PAGE 5   

 241          /*******************************************************************************
 242          * 函数名 : Find
 243          * 描述   : 判断缓存中是否含有指定的字符串
 244          * 输入   : 
 245          * 输出   : 
 246          * 返回   : unsigned char:1 找到指定字符，0 未找到指定字符 
 247          * 注意   : 
 248          *******************************************************************************/
 249          
 250          u8 Find(u8 *a)
 251          { 
 252   1        if(strstr(Uart1_Buf,a)!=NULL)
 253   1            return 1;
 254   1        else
 255   1            return 0;
 256   1      }
 257          
 258          /*******************************************************************************
 259          * 函数名 : Second_AT_Command
 260          * 描述   : 发送AT指令函数
 261          * 输入   : 发送数据的指针、发送等待时间(单位：S)
 262          * 输出   : 
 263          * 返回   : 
 264          * 注意   : 
 265          *******************************************************************************/
 266          
 267          void Second_AT_Command(u8 *b,u8 *a,u8 wait_time)         
 268          {
 269   1        u8 i;
 270   1        u8 *c;
 271   1        c = b;                    //保存字符串地址到c
 272   1        CLR_Buf1(); 
 273   1        i = 0;
 274   1        while(i == 0)                    
 275   1        {
 276   2          if(!Find(a)) 
 277   2          {
 278   3            if(Timer0_start == 0)
 279   3            {
 280   4              b = c;              //将字符串地址给b
 281   4              for (b; *b!='\0';b++)
 282   4              {
 283   5                UART1_SendData(*b);
 284   5              }
 285   4              UART1_SendLR(); 
 286   4              Times = 0;
 287   4              shijian = wait_time;
 288   4              Timer0_start = 1;
 289   4             }
 290   3          }
 291   2          else
 292   2          {
 293   3            i = 1;
 294   3            Timer0_start = 0;
 295   3          }
 296   2        }
 297   1        CLR_Buf1(); 
 298   1      }
 299          
 300          /*******************************************************************************
 301          * 函数名 : Set_ATE0
 302          * 描述   : 取消回显
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:55:59 PAGE 6   

 303          * 输入   : 
 304          * 输出   : 
 305          * 返回   : 
 306          * 注意   : 
 307          *******************************************************************************/
 308          void Set_ATE0(void)
 309          {
 310   1        Second_AT_Command("ATE0","OK",3);               //取消回显    
 311   1      }
 312          /*******************************************************************************
 313          * 函数名 : Connect_Server
 314          * 描述   : GPRS连接服务器函数
 315          * 输入   : 
 316          * 输出   : 
 317          * 返回   : 
 318          * 注意   : 
 319          *******************************************************************************/
 320          void Connect_Server(void)
 321          {
 322   1        UART1_SendString("AT+CIPCLOSE=1");  //关闭连接
 323   1        delay_ms(5);
 324   1        Second_AT_Command("AT+CIPSHUT","SHUT OK",2);    //关闭移动场景
 325   1        Second_AT_Command("AT+CGCLASS=\"B\"","OK",2);//设置GPRS移动台类别为B,支持包交换和数据交换 
 326   1        Second_AT_Command("AT+CGDCONT=1,\"IP\",\"CMNET\"","OK",2);//设置PDP上下文,互联网接协议,接入点等信息
 327   1        Second_AT_Command("AT+CGATT=1","OK",2);//附着GPRS业务
 328   1        Second_AT_Command("AT+CIPCSGP=1,\"CMNET\"","OK",2);//设置为GPRS连接模式
 329   1        Second_AT_Command("AT+CIPHEAD=1","OK",2);//设置接收数据显示IP头(方便判断数据来源,仅在单路连接有效)
 330   1        Second_AT_Command(string,"OK",5); 
 331   1        delay_ms(5);
 332   1        CLR_Buf1();
 333   1      }
 334          /*******************************************************************************
 335          * 函数名 : Rec_Server_Data
 336          * 描述   : 接收服务器数据函数
 337          * 输入   : 
 338          * 输出   : 
 339          * 返回   : 
 340          * 注意   : 
 341          *******************************************************************************/
 342          void Rec_Server_Data(void)
 343          {
 344   1        if(strstr(Uart1_Buf,"+IPD")!=NULL)      //若缓存字符串中含有^SISR
 345   1        { 
 346   2          Heartbeat=0;  //清除心跳帧计数器
 347   2          Heart_beat=0;
 348   2          delay_ms(10);
 349   2          if(strstr(Uart1_Buf,"onled")!=NULL)
 350   2          {
 351   3            LED = 0;
 352   3          }
 353   2          else if(strstr(Uart1_Buf,"offled")!=NULL)
 354   2          {
 355   3            LED = 1;
 356   3          }
 357   2          CLR_Buf1();
 358   2          Heart_beat=1;//发送应答数据，告诉服务器收到数据   
 359   2        }
 360   1      }
 361          /*******************************************************************************
 362          * 函数名 : Send_OK
 363          * 描述   : 发送数据应答服务器的指令，该函数在有两功能
 364                    1：接收到服务器的数据后，应答服务器
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:55:59 PAGE 7   

 365                    2：服务器无下发数据时，每隔10秒发送一帧心跳，保持与服务器连接
 366          * 输入   : 
 367          * 输出   : 
 368          * 返回   : 
 369          * 注意   : 
 370          *******************************************************************************/
 371          void Send_OK(void)
 372          {
 373   1        Second_AT_Command("AT+CIPSEND",">",2);
 374   1        Second_AT_Command("OK\32\0","SEND OK",8);;      //回复OK
 375   1        delay_ms(10);
 376   1        CLR_Buf1(); 
 377   1      }
 378          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    801    ----
   CONSTANT SIZE    =    224    ----
   XDATA SIZE       =    200    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     10      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
