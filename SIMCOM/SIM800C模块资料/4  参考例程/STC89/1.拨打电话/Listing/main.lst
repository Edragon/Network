C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:57:37 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\Output\main.obj
COMPILER INVOKED BY: E:\mcu_keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND PRINT(..\Listing\main.lst) TABS(2) OBJ
                    -ECT(..\Output\main.obj)

line level    source

   1          /**********************************************************************************
   2           * 工程名  :拨打电话
   3           * 描述    :通过C51开发板控制模块拨打指定电话号
   4           * 实验平台:C51
   5           * 库版本  :
   6          
   7           * 硬件连接说明
   8             使用单片串口与GPRS模块通信 
   9             C51        GPRS模块
  10             P30 (RXD)->RXD
  11             P31 (TXD)->TXD
  12             GND      ->GND
  13             P34      ->PWR
  14          
  15           * 软件功能说明
  16             板子上电后运行指示灯RUNING_LED会以一秒的频率闪烁
  17             通过修改*phone = "ATD10086;\r\n"可以修改拨叫方电话
  18          **********************************************************************************/
  19          #include "config.h"
  20          #include "string.h"
  21          #include "delay.h"
  22          #include "uart.h"
  23          
  24          #define Buf1_Max 200            //串口缓存长度
  25          /*************  本地常量声明  **************/
  26          sbit RUNING_LED = P1^2;         //运行指示灯
  27          
  28          
  29          /*************  本地变量声明  **************/
  30          xdata u8 Uart1_Buf[Buf1_Max];
  31          
  32          u8 Times=0,First_Int = 0,shijian=0;
  33          bdata u8 Flag;//定时器标志位
  34          sbit Timer0_start =Flag^0;  //定时器0延时启动计数器
  35          
  36          static unsigned char *phone = "ATD13798983973;\r\n"; //拨打电话，修改这里可以修改拨打的电话。
  37          
  38          /*************  本地函数声明  **************/
  39          void GPIO_config(void); //引脚初始化
  40          void Timer0Init(void);  //定时器0初始化
  41          void CLR_Buf1(void);    //清串口接收缓存
  42          void Wait_CREG(void);   //查询等待模块注册完成
  43          
  44          /*************  外部函数和变量声明*****************/
  45          
  46          
  47          
  48          
  49          /*******************************************************************************
  50          * 函数名 : main 
  51          * 描述   : 主函数
  52          * 输入   : 
  53          * 输出   : 
  54          * 返回   : 
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:57:37 PAGE 2   

  55          * 注意   : 串口波特率是9600，GPRS模块默认波特率是115200，需要自己通过串口助手修改
  56                     为9600方可使用。
  57          *******************************************************************************/
  58          void main(void)
  59          {
  60   1        Timer0Init();  //初始化定时器0
  61   1        GPIO_config();
  62   1        EA=1; //开总中断
  63   1        Uart1Init();  //初始化串口9600
  64   1        Wait_CREG();  //查询模块是否注册成功
  65   1        UART1_SendString(phone);  //拨打电话
  66   1        while(1)
  67   1        {
  68   2          ;
  69   2        }
  70   1        
  71   1      }
  72          
  73          /*******************************************************************************
  74          * 函数名 : Uart1 
  75          * 描述   : 串口1中断服务入口函数
  76          * 输入   : 
  77          * 输出   : 
  78          * 返回   : 
  79          * 注意   : 
  80          *******************************************************************************/
  81          void Uart1() interrupt 4
  82          {
  83   1          if (RI)
  84   1          {
  85   2            RI = 0;                 //清除RI位
  86   2            Uart1_Buf[First_Int] = SBUF;      //将接收到的字符串存到缓存中
  87   2            First_Int++;                      //缓存指针向后移动
  88   2            if(First_Int > Buf1_Max)          //如果缓存满,将缓存指针指向缓存的首地址
  89   2            {
  90   3              First_Int = 0;
  91   3            }
  92   2          }
  93   1          if (TI)
  94   1          {
  95   2              TI = 0;                 //清除TI位
  96   2          }
  97   1      }
  98          /*******************************************************************************
  99          * 函数名 : Timer0_ISR
 100          * 描述   : 定时器0中断服务入口函数,20ms中断一次
 101          * 输入   : 
 102          * 输出   : 
 103          * 返回   : 
 104          * 注意   : 
 105          *******************************************************************************/
 106          void Timer0_ISR() interrupt 1
 107          {
 108   1        static u8 Time_count=0;
 109   1        TL0 = 0x00;     //重置定时器初值
 110   1        TH0 = 0xB8;     //重置定时器初值
 111   1        TR0=0;//关定时器
 112   1        Time_count++;
 113   1        if(count_20ms) //20ms延时计数器
 114   1          count_20ms--;
 115   1        if(Time_count>=50)
 116   1        {
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:57:37 PAGE 3   

 117   2          Time_count = 0;
 118   2          RUNING_LED =~RUNING_LED;
 119   2        }
 120   1      
 121   1        TR0=1;//开定时器
 122   1      }
 123          
 124          /*******************************************************************************
 125          * 函数名 : GPIO_config
 126          * 描述   : IO口配置函数
 127          * 输入   : 
 128          * 输出   : 
 129          * 返回   : 
 130          * 注意   : 
 131          *******************************************************************************/
 132          void  GPIO_config(void)
 133          {
 134   1          RUNING_LED=0;
 135   1      }
 136          /*******************************************************************************
 137          * 函数名 : Timer0Init
 138          * 描述   : 定时器0初始化，20ms定时
 139          * 输入   : 
 140          * 输出   : 
 141          * 返回   : 
 142          * 注意   : 
 143          *******************************************************************************/
 144          void Timer0Init(void)   //20毫秒@11.0592MHz
 145          {
 146   1        AUXR &= 0x7F;   //定时器时钟12T模式
 147   1        TMOD &= 0xF0;   //
 148   1        TMOD |= 0x01;   //设置定时器模式，16位定时器
 149   1        TL0 = 0x00;     //设置定时器初值
 150   1        TH0 = 0xB8;     //设置定时器初值
 151   1        TF0 = 0;        //清TF0标志
 152   1        TR0 = 1;        //定时器0开始计时
 153   1        ET0 = 1;        //使能定时器0中断
 154   1      }
 155          /*******************************************************************************
 156          * 函数名 : CLR_Buf1
 157          * 描述   : 清除串口2缓存数据
 158          * 输入   : 
 159          * 输出   : 
 160          * 返回   : 
 161          * 注意   : 
 162          *******************************************************************************/
 163          void CLR_Buf1(void)
 164          {
 165   1        u16 k;
 166   1        for(k=0;k<Buf1_Max;k++)      //将缓存内容清零
 167   1        {
 168   2          Uart1_Buf[k] = 0x00;
 169   2        }
 170   1          First_Int = 0;              //接收字符串的起始存储位置
 171   1      }
 172          
 173          /*******************************************************************************
 174          * 函数名 : Wait_CREG
 175          * 描述   : 等待模块注册成功
 176          * 输入   : 
 177          * 输出   : 
 178          * 返回   : 
C51 COMPILER V9.00   MAIN                                                                  11/08/2016 17:57:37 PAGE 4   

 179          * 注意   : 
 180          *******************************************************************************/
 181          void Wait_CREG(void)
 182          {
 183   1        u8 i;
 184   1        u8 k;
 185   1        i = 0;
 186   1        CLR_Buf1();
 187   1        while(i == 0)             
 188   1        {
 189   2          CLR_Buf1();        
 190   2          UART1_SendString("AT+CREG?"); //发送查询模块注册状态
 191   2          UART1_SendLR();
 192   2          delay_ms(250);//延时5s              
 193   2            for(k=0;k<Buf1_Max;k++)           
 194   2            {
 195   3            if(Uart1_Buf[k] == ':')
 196   3            {
 197   4              if((Uart1_Buf[k+4] == '1')||(Uart1_Buf[k+4] == '5'))  //说模块注册成功
 198   4              {
 199   5                i = 1;
 200   5                break;
 201   5              }
 202   4            }
 203   3          }
 204   2        }
 205   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    251    ----
   CONSTANT SIZE    =     27    ----
   XDATA SIZE       =    200    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
